import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:spaced_learning_app/core/theme/app_dimens.dart';
import 'package:spaced_learning_app/domain/models/repetition.dart';

// Define the M3ColorPair type (unchanged)
typedef M3ColorPair = ({Color container, Color onContainer});

/// Card representing a repetition session, styled by the AppTheme
/// (which should be generated by FlexColorScheme).
class RepetitionCard extends StatelessWidget {
  final Repetition repetition;
  final bool isHistory;
  final VoidCallback? onMarkCompleted;
  final VoidCallback? onSkip;

  // Thay đổi: cập nhật kiểu của onReschedule để nhận một tham số DateTime
  final Function(DateTime)? onReschedule;
  final ThemeData? theme;

  const RepetitionCard({
    super.key,
    required this.repetition,
    this.isHistory = false,
    this.onMarkCompleted,
    this.onSkip,
    this.onReschedule,
    this.theme,
  });

  // --- Semantic Color Helpers (unchanged) ---
  /// Returns M3 Tertiary container/onContainer, often used for Success.
  M3ColorPair _getSuccessColors(ColorScheme colorScheme) {
    return (
      container: colorScheme.tertiaryContainer,
      onContainer: colorScheme.onTertiaryContainer,
    );
  }

  /// Returns M3 Secondary container/onContainer, can be used for Warning/Notice.
  M3ColorPair _getWarningColors(ColorScheme colorScheme) {
    return (
      container: colorScheme.secondaryContainer,
      onContainer: colorScheme.onSecondaryContainer,
    );
  }

  /// Returns M3 Error container/onContainer, used for Overdue/Errors.
  M3ColorPair _getErrorColors(ColorScheme colorScheme) {
    return (
      container: colorScheme.errorContainer,
      onContainer: colorScheme.onErrorContainer,
    );
  }

  @override
  Widget build(BuildContext context) {
    // Get theme components once (unchanged)
    final currentTheme = theme ?? Theme.of(context);
    final colorScheme = currentTheme.colorScheme;
    final textTheme = currentTheme.textTheme;
    final dateFormat = DateFormat('dd MMM yyyy');

    // Get derived info and colors using the ColorScheme (unchanged)
    final orderText = _formatRepetitionOrder(repetition.repetitionOrder);
    final statusColors = _getStatusColors(repetition.status, colorScheme);
    final dateText =
        repetition.reviewDate != null
            ? dateFormat.format(repetition.reviewDate!)
            : 'Not scheduled';
    final timeIndicator = _getTimeIndicator(repetition.reviewDate);
    final indicatorColors = _getTimeIndicatorColors(
      repetition.reviewDate,
      colorScheme,
    );

    return Card(
      margin: const EdgeInsets.symmetric(vertical: AppDimens.paddingS),
      elevation:
          isHistory ? (currentTheme.cardTheme.elevation ?? 1.0) * 0.5 : null,
      color: isHistory ? colorScheme.surfaceContainerLow : null,
      child: InkWell(
        onTap:
            (isHistory || repetition.status != RepetitionStatus.notStarted)
                ? null
                : onMarkCompleted,
        borderRadius:
            ((currentTheme.cardTheme.shape as RoundedRectangleBorder?)
                    ?.borderRadius
                as BorderRadius?) ??
            BorderRadius.circular(AppDimens.radiusL),
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingL),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(textTheme, colorScheme, orderText, statusColors),
              const SizedBox(height: AppDimens.spaceM),
              _buildDateRow(
                context,
                textTheme,
                colorScheme,
                dateText,
                timeIndicator,
                indicatorColors,
              ),
              // Only show actions for pending, non-history items
              if (!isHistory &&
                  repetition.status == RepetitionStatus.notStarted)
                _buildActions(context, colorScheme, textTheme),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(
    TextTheme textTheme,
    ColorScheme colorScheme,
    String orderText,
    M3ColorPair statusColors,
  ) {
    // Unchanged header implementation
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          orderText,
          style: textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: colorScheme.onSurface,
          ),
        ),
        Container(
          padding: const EdgeInsets.symmetric(
            horizontal: AppDimens.paddingM,
            vertical: AppDimens.paddingXS,
          ),
          decoration: BoxDecoration(
            color: statusColors.container,
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                _formatStatus(repetition.status),
                style: textTheme.labelSmall?.copyWith(
                  color: statusColors.onContainer,
                  fontWeight: FontWeight.bold,
                ),
              ),
              if (repetition.status == RepetitionStatus.completed) ...[
                const SizedBox(width: AppDimens.spaceXS),
                Icon(
                  Icons.check_circle_outline,
                  size: AppDimens.iconXS,
                  color: statusColors.onContainer,
                ),
              ],
              if (repetition.status == RepetitionStatus.skipped) ...[
                const SizedBox(width: AppDimens.spaceXS),
                Icon(
                  Icons.redo_outlined,
                  size: AppDimens.iconXS,
                  color: statusColors.onContainer,
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildDateRow(
    BuildContext context,
    TextTheme textTheme,
    ColorScheme colorScheme,
    String dateText,
    String timeIndicator,
    M3ColorPair? indicatorColors,
  ) {
    // Unchanged date row implementation
    return Row(
      children: [
        Icon(
          Icons.calendar_today_outlined,
          color: colorScheme.primary,
          size: AppDimens.iconS,
        ),
        const SizedBox(width: AppDimens.spaceS),
        Text(
          dateText,
          style: textTheme.bodyMedium?.copyWith(
            color: colorScheme.onSurfaceVariant,
          ),
        ),
        const Spacer(),
        if (indicatorColors != null && timeIndicator.isNotEmpty)
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppDimens.paddingS,
              vertical: AppDimens.paddingXXS,
            ),
            decoration: BoxDecoration(
              color: indicatorColors.container,
              borderRadius: BorderRadius.circular(AppDimens.radiusS),
            ),
            child: Text(
              timeIndicator,
              style: textTheme.labelSmall?.copyWith(
                color: indicatorColors.onContainer,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildActions(
    BuildContext context,
    ColorScheme colorScheme,
    TextTheme textTheme,
  ) {
    // Get semantic M3 colors (unchanged)
    final rescheduleColor = colorScheme.secondary;
    final rescheduleContainerColors = _getWarningColors(colorScheme);
    final completeColor = colorScheme.tertiary;
    final completeContainerColors = _getSuccessColors(colorScheme);

    return Padding(
      padding: const EdgeInsets.only(top: AppDimens.paddingL),
      child: Wrap(
        alignment: WrapAlignment.end,
        spacing: AppDimens.spaceM,
        runSpacing: AppDimens.spaceS,
        children: [
          // Reschedule Button - Thay đổi: Truyền reviewDate vào
          if (onReschedule != null)
            _buildActionButton(
              textTheme: textTheme,
              colorScheme: colorScheme,
              foregroundColor: rescheduleColor,
              containerColors: rescheduleContainerColors,
              label: 'Reschedule',
              icon: Icons.calendar_month_outlined,
              onPressed: () {
                // Truyền ngày hiện tại của repetition vào callback
                onReschedule?.call(repetition.reviewDate ?? DateTime.now());
              },
            ),

          // Complete Button (unchanged)
          if (onMarkCompleted != null)
            _buildActionButton(
              textTheme: textTheme,
              colorScheme: colorScheme,
              foregroundColor: completeColor,
              containerColors: completeContainerColors,
              label: 'Complete',
              icon: Icons.check_circle_outlined,
              onPressed: onMarkCompleted!,
              showScoreIndicator: true,
            ),
        ],
      ),
    );
  }

  Widget _buildActionButton({
    required TextTheme textTheme,
    required ColorScheme colorScheme,
    required Color foregroundColor,
    required M3ColorPair containerColors,
    required String label,
    required IconData icon,
    required VoidCallback onPressed,
    bool showScoreIndicator = false,
  }) {
    // Unchanged action button implementation
    final buttonStyle = OutlinedButton.styleFrom(
      foregroundColor: foregroundColor,
      side: BorderSide(color: foregroundColor),
      padding: const EdgeInsets.symmetric(horizontal: AppDimens.paddingM),
      textStyle: textTheme.labelLarge,
    ).copyWith(minimumSize: WidgetStateProperty.all(Size.zero));

    final scoreIndicatorBg = containerColors.container.withOpacity(0.4);
    final scoreIndicatorFg = containerColors.onContainer;

    return SizedBox(
      height: AppDimens.buttonHeightM,
      child: OutlinedButton.icon(
        onPressed: onPressed,
        icon: Icon(icon, size: AppDimens.iconS),
        label: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(label),
            if (showScoreIndicator) ...[
              const SizedBox(width: AppDimens.spaceS),
              Container(
                padding: const EdgeInsets.all(AppDimens.paddingXXS + 1),
                decoration: BoxDecoration(
                  color: scoreIndicatorBg,
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  Icons.percent,
                  size: AppDimens.iconXXS,
                  color: scoreIndicatorFg,
                ),
              ),
            ],
          ],
        ),
        style: buttonStyle,
      ),
    );
  }

  // --- Formatting and Logic Helpers (unchanged) ---

  String _formatRepetitionOrder(RepetitionOrder order) {
    switch (order) {
      case RepetitionOrder.firstRepetition:
        return 'Repetition 1';
      case RepetitionOrder.secondRepetition:
        return 'Repetition 2';
      case RepetitionOrder.thirdRepetition:
        return 'Repetition 3';
      case RepetitionOrder.fourthRepetition:
        return 'Repetition 4';
      case RepetitionOrder.fifthRepetition:
        return 'Repetition 5';
    }
  }

  String _formatStatus(RepetitionStatus status) {
    switch (status) {
      case RepetitionStatus.notStarted:
        return 'Pending';
      case RepetitionStatus.completed:
        return 'Completed';
      case RepetitionStatus.skipped:
        return 'Skipped';
    }
  }

  M3ColorPair _getStatusColors(
    RepetitionStatus status,
    ColorScheme colorScheme,
  ) {
    return switch (status) {
      RepetitionStatus.notStarted => (
        container: colorScheme.primaryContainer,
        onContainer: colorScheme.onPrimaryContainer,
      ),
      RepetitionStatus.completed => _getSuccessColors(colorScheme),
      RepetitionStatus.skipped => _getWarningColors(colorScheme),
    };
  }

  String _getTimeIndicator(DateTime? date) {
    if (date == null) return '';
    final now = DateUtils.dateOnly(DateTime.now());
    final target = DateUtils.dateOnly(date);
    final difference = target.difference(now).inDays;

    if (difference < 0) return 'Overdue ${-difference}d';
    if (difference == 0) return 'Today';
    if (difference == 1) return 'Tomorrow';
    return 'In $difference days';
  }

  M3ColorPair? _getTimeIndicatorColors(
    DateTime? date,
    ColorScheme colorScheme,
  ) {
    if (date == null) return null;

    final now = DateUtils.dateOnly(DateTime.now());
    final target = DateUtils.dateOnly(date);
    final difference = target.difference(now).inDays;

    if (difference < 0) {
      return _getErrorColors(colorScheme);
    }
    if (difference == 0) {
      return _getSuccessColors(colorScheme);
    }
    if (difference <= 3) {
      return _getWarningColors(colorScheme);
    }
    return (
      container: colorScheme.secondaryContainer,
      onContainer: colorScheme.onSecondaryContainer,
    );
  }
}
