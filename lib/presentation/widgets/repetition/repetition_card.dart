import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:spaced_learning_app/core/theme/app_dimens.dart'; // Assuming this exists
import 'package:spaced_learning_app/domain/models/repetition.dart'; // Ensure correct path

// Define the M3ColorPair type (unchanged)
typedef M3ColorPair = ({Color container, Color onContainer});

/// Card representing a repetition session, styled by the AppTheme
/// (which should be generated by FlexColorScheme).
class RepetitionCard extends StatelessWidget {
  final Repetition repetition;
  final bool isHistory;
  final VoidCallback? onMarkCompleted;
  final VoidCallback? onSkip; // Callback for skip (if needed later)
  final VoidCallback? onReschedule;
  final ThemeData? theme; // Optional theme override for testing

  const RepetitionCard({
    super.key,
    required this.repetition,
    this.isHistory = false,
    this.onMarkCompleted,
    this.onSkip, // Still here if needed in future
    this.onReschedule,
    this.theme,
  });

  // --- Semantic Color Helpers (using standard ColorScheme slots) ---
  // These now map semantic concepts to M3 roles populated by FlexColorScheme.
  // You might adjust the mapping (e.g., use Primary for Success if it's green)
  // based on your specific FlexColorScheme setup.

  /// Returns M3 Tertiary container/onContainer, often used for Success.
  M3ColorPair _getSuccessColors(ColorScheme colorScheme) {
    return (
      container: colorScheme.tertiaryContainer,
      onContainer: colorScheme.onTertiaryContainer,
    );
  }

  /// Returns M3 Secondary container/onContainer, can be used for Warning/Notice.
  /// If Error is more appropriate, use errorContainer.
  M3ColorPair _getWarningColors(ColorScheme colorScheme) {
    // Using Secondary as a proxy for Warning. Adjust if needed.
    // Could also use colorScheme.errorContainer if the warning is severe.
    return (
      container: colorScheme.secondaryContainer,
      onContainer: colorScheme.onSecondaryContainer,
    );
  }

  /// Returns M3 Error container/onContainer, used for Overdue/Errors.
  M3ColorPair _getErrorColors(ColorScheme colorScheme) {
    return (
      container: colorScheme.errorContainer,
      onContainer: colorScheme.onErrorContainer,
    );
  }

  @override
  Widget build(BuildContext context) {
    // Get theme components once (this works regardless of theme source)
    final currentTheme = theme ?? Theme.of(context);
    final colorScheme = currentTheme.colorScheme;
    final textTheme = currentTheme.textTheme;
    // isDark check might not be strictly needed if ColorScheme handles it all
    // final isDark = currentTheme.brightness == Brightness.dark;
    final dateFormat = DateFormat('dd MMM yyyy'); // Consistent format

    // Get derived info and colors using the ColorScheme
    final orderText = _formatRepetitionOrder(repetition.repetitionOrder);
    final statusColors = _getStatusColors(
      repetition.status,
      colorScheme,
    ); // Pass ColorScheme
    final dateText =
        repetition.reviewDate != null
            ? dateFormat.format(repetition.reviewDate!)
            : 'Not scheduled';
    final timeIndicator = _getTimeIndicator(repetition.reviewDate);
    final indicatorColors = _getTimeIndicatorColors(
      repetition.reviewDate,
      colorScheme,
    ); // Pass ColorScheme

    return Card(
      margin: const EdgeInsets.symmetric(vertical: AppDimens.paddingS),
      // CardTheme (shape, elevation) is applied automatically from currentTheme
      // Adjust elevation and color for history items using M3 roles
      elevation:
          isHistory
              ? (currentTheme.cardTheme.elevation ?? 1.0) *
                  0.5 // Half elevation
              : null, // Use default theme elevation
      color:
          isHistory
              ? colorScheme
                  .surfaceContainerLow // M3 subtle background
              : null, // Use default theme card color
      child: InkWell(
        // Consider if card-level tap is desired vs button-only actions
        onTap:
            (isHistory || repetition.status != RepetitionStatus.notStarted)
                ? null
                : onMarkCompleted, // Example: tap card to complete
        borderRadius:
            ((currentTheme.cardTheme.shape as RoundedRectangleBorder?)
                    ?.borderRadius
                as BorderRadius?) ??
            BorderRadius.circular(AppDimens.radiusL), // Use theme or fallback
        child: Padding(
          padding: const EdgeInsets.all(AppDimens.paddingL),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(textTheme, colorScheme, orderText, statusColors),
              const SizedBox(height: AppDimens.spaceM),
              _buildDateRow(
                context, // Keep context if needed for future locale stuff
                textTheme,
                colorScheme,
                dateText,
                timeIndicator,
                indicatorColors,
              ),
              // Only show actions for pending, non-history items
              if (!isHistory &&
                  repetition.status == RepetitionStatus.notStarted)
                _buildActions(
                  context,
                  colorScheme,
                  textTheme,
                ), // Pass scheme/theme
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(
    TextTheme textTheme,
    ColorScheme colorScheme,
    String orderText,
    M3ColorPair statusColors, // Expects ({Color container, Color onContainer})
  ) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          orderText,
          style: textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: colorScheme.onSurface, // Use clear M3 role
          ),
        ),
        // Status Badge using M3 container/onContainer pattern
        Container(
          padding: const EdgeInsets.symmetric(
            horizontal: AppDimens.paddingM,
            vertical: AppDimens.paddingXS,
          ),
          decoration: BoxDecoration(
            color: statusColors.container, // Background from pair
            borderRadius: BorderRadius.circular(AppDimens.radiusM),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                _formatStatus(repetition.status),
                style: textTheme.labelSmall?.copyWith(
                  color: statusColors.onContainer, // Text color from pair
                  fontWeight: FontWeight.bold,
                ),
              ),
              // Add appropriate icons based on status
              if (repetition.status == RepetitionStatus.completed) ...[
                const SizedBox(width: AppDimens.spaceXS),
                Icon(
                  Icons.check_circle_outline, // Or Icons.task_alt
                  size: AppDimens.iconXS,
                  color: statusColors.onContainer, // Icon color from pair
                ),
              ],
              if (repetition.status == RepetitionStatus.skipped) ...[
                const SizedBox(width: AppDimens.spaceXS),
                Icon(
                  Icons.redo_outlined, // Or Icons.skip_next_outlined
                  size: AppDimens.iconXS,
                  color: statusColors.onContainer, // Icon color from pair
                ),
              ],
              // Could add icon for Pending if desired (e.g., schedule or timer)
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildDateRow(
    BuildContext context,
    TextTheme textTheme,
    ColorScheme colorScheme,
    String dateText,
    String timeIndicator,
    M3ColorPair? indicatorColors, // Nullable pair
  ) {
    return Row(
      children: [
        Icon(
          Icons.calendar_today_outlined, // Standard icon
          color: colorScheme.primary, // Use primary color for emphasis
          size: AppDimens.iconS,
        ),
        const SizedBox(width: AppDimens.spaceS),
        Text(
          dateText,
          style: textTheme.bodyMedium?.copyWith(
            color: colorScheme.onSurfaceVariant, // Subtler text color
          ),
        ),
        const Spacer(), // Push indicator to the right
        // Only show indicator if data and colors exist
        if (indicatorColors != null && timeIndicator.isNotEmpty)
          Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppDimens.paddingS,
              vertical: AppDimens.paddingXXS,
            ),
            decoration: BoxDecoration(
              color: indicatorColors.container, // Background from pair
              borderRadius: BorderRadius.circular(AppDimens.radiusS),
            ),
            child: Text(
              timeIndicator,
              style: textTheme.labelSmall?.copyWith(
                color: indicatorColors.onContainer, // Text color from pair
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildActions(
    BuildContext context,
    ColorScheme colorScheme,
    TextTheme textTheme,
    // bool isDark is no longer needed here if ColorScheme handles it
  ) {
    // Get semantic M3 colors from ColorScheme
    // Mapping: Reschedule -> Warning (Secondary), Complete -> Success (Tertiary)
    final rescheduleColor = colorScheme.secondary; // Main color for button
    final rescheduleContainerColors = _getWarningColors(
      colorScheme,
    ); // Container pair
    final completeColor = colorScheme.tertiary; // Main color for button
    final completeContainerColors = _getSuccessColors(
      colorScheme,
    ); // Container pair

    return Padding(
      padding: const EdgeInsets.only(top: AppDimens.paddingL),
      child: Wrap(
        alignment: WrapAlignment.end, // Align buttons to the right
        spacing: AppDimens.spaceM, // Horizontal space
        runSpacing: AppDimens.spaceS, // Vertical space if wrapping
        children: [
          // Reschedule Button (using Warning/Secondary)
          if (onReschedule != null)
            _buildActionButton(
              textTheme: textTheme,
              colorScheme: colorScheme, // Pass scheme for potential overrides
              foregroundColor: rescheduleColor, // Main semantic color
              containerColors:
                  rescheduleContainerColors, // Container pair for bg/indicator
              label: 'Reschedule',
              icon: Icons.calendar_month_outlined, // Or Icons.update
              onPressed: onReschedule!,
            ),

          // Complete Button (using Success/Tertiary)
          if (onMarkCompleted != null)
            _buildActionButton(
              textTheme: textTheme,
              colorScheme: colorScheme,
              foregroundColor: completeColor, // Main semantic color
              containerColors:
                  completeContainerColors, // Container pair for bg/indicator
              label: 'Complete',
              icon: Icons.check_circle_outlined, // Or Icons.task_alt
              onPressed: onMarkCompleted!,
              showScoreIndicator: true, // Show the % icon
            ),

          // Potential Skip Button (using e.g., surface variant?)
          // if (onSkip != null)
          //   _buildActionButton(
          //     textTheme: textTheme,
          //     colorScheme: colorScheme,
          //     foregroundColor: colorScheme.onSurfaceVariant, // Example subtle color
          //     containerColors: (container: colorScheme.surfaceContainerHighest, onContainer: colorScheme.onSurfaceVariant), // Example
          //     label: 'Skip',
          //     icon: Icons.skip_next_outlined, // Or Icons.redo
          //     onPressed: onSkip!,
          //   ),
        ],
      ),
    );
  }

  Widget _buildActionButton({
    required TextTheme textTheme,
    required ColorScheme colorScheme, // Pass for context
    required Color foregroundColor, // Main semantic color for text/icon/border
    required M3ColorPair
    containerColors, // Container pair for indicator bg etc.
    required String label,
    required IconData icon,
    required VoidCallback onPressed,
    bool showScoreIndicator = false,
  }) {
    // Use the foregroundColor for text, icon, and border
    final buttonStyle = OutlinedButton.styleFrom(
      foregroundColor: foregroundColor, // Text and icon color
      side: BorderSide(color: foregroundColor), // Border color
      padding: const EdgeInsets.symmetric(horizontal: AppDimens.paddingM),
      textStyle: textTheme.labelLarge, // Standard button label style
    ).copyWith(
      // Remove default min size to allow button to shrink wrap content
      minimumSize: WidgetStateProperty.all(Size.zero),
      // M3 state layer opacity - FlexColorScheme often handles this,
      // but you can define it explicitly if needed.
      // overlayColor: WidgetStateProperty.resolveWith<Color?>(
      //   (Set<WidgetState> states) {
      //     if (states.contains(WidgetState.pressed)) {
      //       return foregroundColor.withOpacity(0.12); // M3 press opacity
      //     }
      //     if (states.contains(WidgetState.hovered)) {
      //       return foregroundColor.withOpacity(0.08); // M3 hover opacity
      //     }
      //     if (states.contains(WidgetState.focused)) {
      //       return foregroundColor.withOpacity(0.12); // M3 focus opacity
      //     }
      //     return null; // Defer to default value
      //   },
      // ),
    );

    // Score Indicator styling using the container/onContainer pair
    // Background is a slightly transparent version of the *container* color
    final scoreIndicatorBg = containerColors.container.withOpacity(
      0.4,
    ); // Adjust opacity
    // Icon color is the *onContainer* color
    final scoreIndicatorFg = containerColors.onContainer;

    return SizedBox(
      height: AppDimens.buttonHeightM, // Consistent button height
      child: OutlinedButton.icon(
        onPressed: onPressed,
        icon: Icon(icon, size: AppDimens.iconS),
        label: Row(
          mainAxisSize: MainAxisSize.min, // Keep row tight
          children: [
            Text(label),
            if (showScoreIndicator) ...[
              const SizedBox(width: AppDimens.spaceS),
              // Score Indicator using container colors
              Container(
                padding: const EdgeInsets.all(AppDimens.paddingXXS + 1),
                decoration: BoxDecoration(
                  color: scoreIndicatorBg, // Use calculated bg
                  shape: BoxShape.circle, // Circular shape
                ),
                child: Icon(
                  Icons.percent,
                  size: AppDimens.iconXXS,
                  color: scoreIndicatorFg, // Use calculated fg
                ),
              ),
            ],
          ],
        ),
        style: buttonStyle,
      ),
    );
  }

  // --- Formatting and Logic Helpers ---

  String _formatRepetitionOrder(RepetitionOrder order) {
    // (Unchanged)
    switch (order) {
      case RepetitionOrder.firstRepetition:
        return 'Repetition 1';
      case RepetitionOrder.secondRepetition:
        return 'Repetition 2';
      case RepetitionOrder.thirdRepetition:
        return 'Repetition 3';
      case RepetitionOrder.fourthRepetition:
        return 'Repetition 4';
      case RepetitionOrder.fifthRepetition:
        return 'Repetition 5';
    }
  }

  String _formatStatus(RepetitionStatus status) {
    // (Unchanged)
    switch (status) {
      case RepetitionStatus.notStarted:
        return 'Pending';
      case RepetitionStatus.completed:
        return 'Completed';
      case RepetitionStatus.skipped:
        return 'Skipped';
    }
  }

  // Get M3ColorPair for the Status Badge based on status
  M3ColorPair _getStatusColors(
    RepetitionStatus status,
    ColorScheme colorScheme,
  ) {
    return switch (status) {
      // Pending: Use Primary container (often default accent)
      RepetitionStatus.notStarted => (
        container: colorScheme.primaryContainer,
        onContainer: colorScheme.onPrimaryContainer,
      ),
      // Completed: Use Success mapping (Tertiary)
      RepetitionStatus.completed => _getSuccessColors(colorScheme),
      // Skipped: Use Warning mapping (Secondary)
      RepetitionStatus.skipped => _getWarningColors(colorScheme),
    };
  }

  String _getTimeIndicator(DateTime? date) {
    // (Unchanged, uses DateUtils)
    if (date == null) return '';
    final now = DateUtils.dateOnly(DateTime.now());
    final target = DateUtils.dateOnly(date);
    final difference = target.difference(now).inDays;

    if (difference < 0) return 'Overdue ${-difference}d';
    if (difference == 0) return 'Today';
    if (difference == 1) return 'Tomorrow';
    return 'In $difference days';
  }

  // Get M3ColorPair? for the Time Indicator badge based on due date proximity
  M3ColorPair? _getTimeIndicatorColors(
    DateTime? date,
    ColorScheme colorScheme,
  ) {
    if (date == null) return null;

    final now = DateUtils.dateOnly(DateTime.now());
    final target = DateUtils.dateOnly(date);
    final difference = target.difference(now).inDays;

    // Overdue: Use Error colors
    if (difference < 0) {
      return _getErrorColors(colorScheme);
    }
    // Due Today: Use Success mapping (Tertiary) - high importance
    if (difference == 0) {
      return _getSuccessColors(colorScheme);
    }
    // Due Soon (1-3 days): Use Warning mapping (Secondary)
    if (difference <= 3) {
      return _getWarningColors(colorScheme);
    }
    // Due Later: Use a more neutral M3 container (e.g., Secondary or Surface)
    // Let's keep Secondary Container for consistency with Warning mapping here,
    // but could use surfaceContainerHighest etc. for less emphasis.
    return (
      container: colorScheme.secondaryContainer, // Or e.g., surfaceContainer
      onContainer: colorScheme.onSecondaryContainer, // Or onSurfaceVariant
    );
  }
}
